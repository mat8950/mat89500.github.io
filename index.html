<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mes Marque-pages</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- CSS Fallback Background (shown if WebGL fails) -->
    <div id="css-fallback-bg">
        <div class="grid-container">
            <div class="grid-lines"></div>
        </div>
        <div class="floating-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        <div class="vertical-lines">
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
            <div class="v-line"></div>
        </div>
    </div>

    <!-- 3D Background (WebGL) -->
    <canvas id="bg-canvas"></canvas>

    <!-- Audio Visualizer -->
    <canvas id="audio-visualizer"></canvas>

    <header role="banner">
        <h1>Marque-pages</h1>
        <div class="header-controls">
            <label for="search" class="visually-hidden">Rechercher des marque-pages</label>
            <input type="text" id="search" placeholder="Rechercher..." aria-label="Rechercher des marque-pages">
            <button id="theme-toggle" title="Changer de thème" aria-label="Basculer entre mode clair et sombre">
                <svg width="20" height="20" viewBox="0 0 20 20" aria-hidden="true">
                    <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill="currentColor"/>
                </svg>
            </button>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar" role="navigation" aria-label="Navigation des dossiers">
            <h2 id="folders-heading">Dossiers</h2>
            <div id="folder-tree" role="tree" aria-labelledby="folders-heading"></div>
        </aside>

        <main class="content" role="main" aria-label="Liste des marque-pages">
            <nav id="breadcrumb" aria-label="Fil d'Ariane"></nav>
            <div id="bookmarks-grid" role="list" aria-label="Marque-pages"></div>
            <div id="empty-state" style="display: none;" role="status" aria-live="polite">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" aria-hidden="true">
                    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                </svg>
                <p>Aucun marque-page trouvé</p>
            </div>
        </main>
    </div>

    <!-- Audio Controls -->
    <div id="audio-controls">
        <button id="audio-toggle">PLAY</button>
        <input type="range" id="volume-slider" min="0" max="100" value="30">
    </div>

    <!-- Background Audio (local file) -->
    <audio id="bg-audio" loop preload="auto">
        <source src="ambient.mp3" type="audio/mpeg">
    </audio>

    <script src="script.js"></script>

    <script>
        // ===== WEBGL DETECTION & FALLBACK =====
        function isWebGLAvailable() {
            try {
                const canvas = document.createElement('canvas');
                return !!(window.WebGLRenderingContext &&
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
            } catch (e) {
                return false;
            }
        }

        const cssFallback = document.getElementById('css-fallback-bg');
        const webglCanvas = document.getElementById('bg-canvas');

        if (isWebGLAvailable()) {
            // Hide CSS fallback, show WebGL
            cssFallback.style.display = 'none';
            webglCanvas.style.display = 'block';

            // Load Three.js dynamically
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.onload = initThreeJS;
            script.onerror = function() {
                // If Three.js fails to load, show CSS fallback
                cssFallback.style.display = 'block';
                webglCanvas.style.display = 'none';
            };
            document.head.appendChild(script);
        } else {
            // Show CSS fallback
            cssFallback.style.display = 'block';
            webglCanvas.style.display = 'none';
            console.log('WebGL not available, using CSS fallback');
        }

        function initThreeJS() {
            try {
                const canvas = document.getElementById('bg-canvas');
                const renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                const scene = new THREE.Scene();

                // Camera
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 15);
                camera.lookAt(0, 0, 0);

                // === INFINITE GRID ===
                const gridSize = 100;
                const gridDivisions = 50;
                const gridGeometry = new THREE.BufferGeometry();
                const gridPositions = [];
                const gridColors = [];
                const halfSize = gridSize / 2;
                const step = gridSize / gridDivisions;

                for (let i = -halfSize; i <= halfSize; i += step) {
                    gridPositions.push(-halfSize, 0, i, halfSize, 0, i);
                    const alpha1 = 1 - Math.abs(i) / halfSize;
                    gridColors.push(1, 1, 1, alpha1 * 0.3, 1, 1, 1, alpha1 * 0.3);
                }

                for (let i = -halfSize; i <= halfSize; i += step) {
                    gridPositions.push(i, 0, -halfSize, i, 0, halfSize);
                    const alpha1 = 1 - Math.abs(i) / halfSize;
                    gridColors.push(1, 1, 1, alpha1 * 0.3, 1, 1, 1, alpha1 * 0.3);
                }

                gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
                gridGeometry.setAttribute('color', new THREE.Float32BufferAttribute(gridColors, 4));

                const gridMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.5
                });

                const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
                grid.position.y = -2;
                scene.add(grid);

                // === FLOATING PARTICLES ===
                const particlesCount = 500;
                const particlesGeometry = new THREE.BufferGeometry();
                const particlesPositions = new Float32Array(particlesCount * 3);

                for (let i = 0; i < particlesCount; i++) {
                    particlesPositions[i * 3] = (Math.random() - 0.5) * 80;
                    particlesPositions[i * 3 + 1] = Math.random() * 30 - 5;
                    particlesPositions[i * 3 + 2] = (Math.random() - 0.5) * 80;
                }

                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlesPositions, 3));

                const particlesMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.08,
                    transparent: true,
                    opacity: 0.6,
                    sizeAttenuation: true
                });

                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particles);

                // === VERTICAL LINES ===
                const linesGroup = new THREE.Group();
                for (let i = 0; i < 30; i++) {
                    const lineGeometry = new THREE.BufferGeometry();
                    const x = (Math.random() - 0.5) * 60;
                    const z = (Math.random() - 0.5) * 60;
                    const height = Math.random() * 15 + 5;

                    lineGeometry.setFromPoints([
                        new THREE.Vector3(x, -2, z),
                        new THREE.Vector3(x, height, z)
                    ]);

                    const lineMaterial = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: Math.random() * 0.2 + 0.05
                    });

                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    line.userData = {
                        speed: Math.random() * 0.02 + 0.005,
                        maxOpacity: Math.random() * 0.2 + 0.05
                    };
                    linesGroup.add(line);
                }
                scene.add(linesGroup);

                // === WIREFRAME CUBES ===
                const cubesGroup = new THREE.Group();
                for (let i = 0; i < 8; i++) {
                    const size = Math.random() * 2 + 0.5;
                    const cubeGeometry = new THREE.BoxGeometry(size, size, size);
                    const edges = new THREE.EdgesGeometry(cubeGeometry);
                    const cubeMaterial = new THREE.LineBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.15
                    });
                    const cube = new THREE.LineSegments(edges, cubeMaterial);

                    cube.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 10 + 2,
                        (Math.random() - 0.5) * 40
                    );

                    cube.userData = {
                        rotationSpeed: {
                            x: (Math.random() - 0.5) * 0.01,
                            y: (Math.random() - 0.5) * 0.01,
                            z: (Math.random() - 0.5) * 0.01
                        },
                        floatSpeed: Math.random() * 0.5 + 0.2,
                        floatOffset: Math.random() * Math.PI * 2
                    };

                    cubesGroup.add(cube);
                }
                scene.add(cubesGroup);

                // === RINGS ===
                const ringsGroup = new THREE.Group();
                for (let i = 0; i < 3; i++) {
                    const ringGeometry = new THREE.RingGeometry(8 + i * 6, 8.1 + i * 6, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.05 - i * 0.01,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = -1.9;
                    ringsGroup.add(ring);
                }
                scene.add(ringsGroup);

                // === MOUSE INTERACTION ===
                let mouseX = 0, mouseY = 0, targetX = 0, targetY = 0;

                document.addEventListener('mousemove', (e) => {
                    mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
                    mouseY = (e.clientY / window.innerHeight - 0.5) * 2;
                });

                // === ANIMATION ===
                const clock = new THREE.Clock();

                function animate() {
                    requestAnimationFrame(animate);
                    const elapsedTime = clock.getElapsedTime();

                    targetX += (mouseX * 3 - targetX) * 0.02;
                    targetY += (-mouseY * 2 - targetY) * 0.02;
                    camera.position.x = targetX;
                    camera.position.y = 5 + targetY;
                    camera.lookAt(0, 0, 0);

                    grid.position.z = (elapsedTime * 2) % step;

                    const positions = particles.geometry.attributes.position.array;
                    for (let i = 0; i < particlesCount; i++) {
                        positions[i * 3 + 1] += Math.sin(elapsedTime + i) * 0.002;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    particles.rotation.y = elapsedTime * 0.02;

                    linesGroup.children.forEach((line, i) => {
                        const pulse = Math.sin(elapsedTime * line.userData.speed * 50 + i) * 0.5 + 0.5;
                        line.material.opacity = line.userData.maxOpacity * pulse;
                    });

                    cubesGroup.children.forEach((cube) => {
                        cube.rotation.x += cube.userData.rotationSpeed.x;
                        cube.rotation.y += cube.userData.rotationSpeed.y;
                        cube.rotation.z += cube.userData.rotationSpeed.z;
                        cube.position.y += Math.sin(elapsedTime * cube.userData.floatSpeed + cube.userData.floatOffset) * 0.005;
                    });

                    ringsGroup.rotation.y = elapsedTime * 0.05;

                    renderer.render(scene, camera);
                }

                animate();

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

            } catch (e) {
                console.error('WebGL initialization failed:', e);
                document.getElementById('css-fallback-bg').style.display = 'block';
                document.getElementById('bg-canvas').style.display = 'none';
            }
        }

        // ===== AUDIO CONTROLLER =====
        const audio = document.getElementById('bg-audio');
        const audioToggle = document.getElementById('audio-toggle');
        const volumeSlider = document.getElementById('volume-slider');
        const visualizerCanvas = document.getElementById('audio-visualizer');
        const visualizerCtx = visualizerCanvas.getContext('2d');

        function resizeVisualizer() {
            visualizerCanvas.width = window.innerWidth;
            visualizerCanvas.height = 40;
        }
        resizeVisualizer();
        window.addEventListener('resize', resizeVisualizer);

        let audioContext, analyser, source, dataArray, isPlaying = false;
        let audioContextInitialized = false;

        // ===== PERSISTANCE ÉTAT =====
        const STORAGE_KEY_AUDIO = 'audioEnabled';
        const STORAGE_KEY_SCROLL = 'scrollPosition';
        const STORAGE_KEY_VOLUME = 'audioVolume';

        // Restaurer positions de scroll (page, sidebar, contenu)
        const savedScroll = localStorage.getItem(STORAGE_KEY_SCROLL);
        const savedSidebarScroll = localStorage.getItem('sidebarScroll');
        const savedContentScroll = localStorage.getItem('contentScroll');

        if (savedScroll) {
            window.scrollTo(0, parseInt(savedScroll));
        }

        // Restaurer scroll sidebar et contenu après chargement
        window.addEventListener('load', () => {
            const sidebar = document.querySelector('.sidebar');
            const content = document.querySelector('.content');

            if (savedSidebarScroll && sidebar) {
                sidebar.scrollTop = parseInt(savedSidebarScroll);
            }
            if (savedContentScroll && content) {
                setTimeout(() => {
                    content.scrollTop = parseInt(savedContentScroll);
                }, 200);
            }
        });

        // Sauvegarder positions de scroll
        window.addEventListener('beforeunload', () => {
            const sidebar = document.querySelector('.sidebar');
            const content = document.querySelector('.content');

            localStorage.setItem(STORAGE_KEY_SCROLL, window.scrollY.toString());
            if (sidebar) localStorage.setItem('sidebarScroll', sidebar.scrollTop.toString());
            if (content) localStorage.setItem('contentScroll', content.scrollTop.toString());
        });

        // Restaurer le volume sauvegardé (ou 45% par défaut)
        const savedVolume = localStorage.getItem(STORAGE_KEY_VOLUME);
        if (savedVolume) {
            audio.volume = parseFloat(savedVolume);
            volumeSlider.value = parseFloat(savedVolume) * 100;
        } else {
            audio.volume = 0.45;
            volumeSlider.value = 45;
        }

        // Sauvegarder le volume quand il change
        volumeSlider.addEventListener('input', () => {
            const volume = volumeSlider.value / 100;
            audio.volume = volume;
            localStorage.setItem(STORAGE_KEY_VOLUME, volume.toString());
        });

        function initAudioContext() {
            if (audioContextInitialized) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                analyser.fftSize = 256;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                audioContextInitialized = true;
                console.log('AudioContext initialisé avec succès');
            } catch (e) {
                console.error('Erreur initialisation AudioContext:', e);
            }
        }

        function drawVisualizer() {
            if (!isPlaying || !analyser) return;
            requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(dataArray);

            const isLightMode = document.body.classList.contains('light-mode');

            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            const barWidth = visualizerCanvas.width / dataArray.length;
            for (let i = 0; i < dataArray.length; i++) {
                const barHeight = (dataArray[i] / 255) * visualizerCanvas.height;
                const x = i * barWidth;
                const y = visualizerCanvas.height - barHeight;
                const opacity = 0.1 + (dataArray[i] / 255) * 0.4;

                if (isLightMode) {
                    visualizerCtx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                } else {
                    visualizerCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                }
                visualizerCtx.fillRect(x, y, barWidth - 1, barHeight);
            }
        }

        // Fonction pour démarrer l'audio
        function startAudio() {
            // S'assurer que l'AudioContext est initialisé
            initAudioContext();

            // Reprendre l'AudioContext s'il est suspendu
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            audio.play().then(() => {
                audioToggle.textContent = 'PAUSE';
                audioToggle.classList.add('playing');
                isPlaying = true;
                localStorage.setItem(STORAGE_KEY_AUDIO, 'true');
                drawVisualizer();
                console.log('Audio démarré');
            }).catch(e => {
                console.error('Échec lecture audio:', e);
            });
        }

        // Fonction pour arrêter l'audio
        function stopAudio() {
            audio.pause();
            audioToggle.textContent = 'PLAY';
            audioToggle.classList.remove('playing');
            isPlaying = false;
            localStorage.setItem(STORAGE_KEY_AUDIO, 'false');
        }

        // Bouton toggle
        audioToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isPlaying) {
                stopAudio();
            } else {
                startAudio();
            }
        });

        // Autoplay au premier clic/touche sur la page (une seule fois)
        let audioInitialized = false;

        function autoplayOnInteraction() {
            if (isPlaying || audioInitialized) return;
            audioInitialized = true;
            startAudio();
            document.removeEventListener('click', autoplayOnInteraction);
            document.removeEventListener('keydown', autoplayOnInteraction);
        }

        // Écouter uniquement si l'audio n'a jamais été initialisé dans cette session
        document.addEventListener('click', autoplayOnInteraction);
        document.addEventListener('keydown', autoplayOnInteraction);

        // Raccourcis clavier
        document.addEventListener('keydown', (e) => {
            if (e.key === 'm' || e.key === 'M') {
                audio.muted = !audio.muted;
            }
            if (e.key === ' ' && e.target === document.body) {
                e.preventDefault();
                audioToggle.click();
            }
        });
    </script>
</body>
</html>
